var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require('../scheduler/async');
var isDate_1 = require('../util/isDate');
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
var Notification_1 = require('../Notification');
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * ![](delay.png)
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * ## Examples
 * Delay each click by one second
 * ```ts
 * import { fromEvent } from 'rxjs';
 * import { delay } from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 * ```
 *
 * Delay all clicks until a future date happens
 * ```ts
 * import { fromEvent } from 'rxjs';
 * import { delay } from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const date = new Date('March 15, 2050 12:00:00'); // in the future
 * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
exports.delay = delay;
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
})();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber() {
        _super.apply(this, arguments);
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = ;
    return DelaySubscriber;
})(Subscriber_1.Subscriber);
void {
    const: source = state.source,
    const: queue = source.queue,
    const: scheduler = state.scheduler,
    const: destination = state.destination,
    while: function (queue, length) {
        if (length === void 0) { length =  > 0 && (queue[0].time - scheduler.now()) <= 0; }
        queue.shift().notification.observe(destination);
    },
    if: function (queue, length) {
        if (length === void 0) { length =  > 0; }
        var delay = Math.max(0, queue[0].time - scheduler.now());
        this.schedule(state, delay);
    }, else: {
        this: .unsubscribe(),
        source: .active = false
    }
};
constructor(destination, Subscriber_1.Subscriber < T > , private, delay, number, private, scheduler, SchedulerLike);
{
    _super.call(this, destination);
}
_schedule(scheduler, SchedulerLike);
void {
    this: .active = true,
    const: destination = this.destination, as: Subscription_1.Subscription,
    destination: .add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
        source: this, destination: this.destination, scheduler: scheduler
    }))
};
scheduleNotification(notification, Notification_1.Notification(), void {
    if: function () { }, this: .errored === true });
{
    return;
}
var scheduler = this.scheduler;
var message = new DelayMessage(scheduler.now() + this.delay, notification);
this.queue.push(message);
if (this.active === false) {
    this._schedule(scheduler);
}
_next(value, T);
{
    this.scheduleNotification(Notification_1.Notification.createNext(value));
}
_error(err, any);
{
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
}
_complete();
{
    this.scheduleNotification(Notification_1.Notification.createComplete());
    this.unsubscribe();
}
var DelayMessage = (function () {
    function DelayMessage(readonly, number, readonly, Notification) {
        if (readonly === void 0) { readonly = time; }
        if (readonly === void 0) { readonly = notification; }
        if (Notification === void 0) { Notification = ; }
        this.readonly = readonly;
        this.readonly = readonly;
    }
    return DelayMessage;
})();
