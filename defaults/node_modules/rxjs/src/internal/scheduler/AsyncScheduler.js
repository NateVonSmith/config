var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = require('../Scheduler');
var AsyncAction_1 = require('./AsyncAction');
var Subscription_1 = require('../Subscription');
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        var _this = this;
        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
        _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        });
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         * @deprecated internal use only
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         * @deprecated internal use only
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.schedule = ;
    return AsyncScheduler;
})(Scheduler_1.Scheduler);
exports.AsyncScheduler = AsyncScheduler;
void , delay;
number = 0, state ?  : T;
Subscription_1.Subscription;
{
    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
        return AsyncScheduler.delegate.schedule(work, delay, state);
    }
    else {
        return _super.schedule.call(this, work, delay, state);
    }
}
flush(action, AsyncAction_1.AsyncAction(), void {
    const: (_a = this, actions = _a.actions, _a),
    if: function () { }, this: .active });
{
    actions.push(action);
    return;
}
var error;
this.active = true;
do {
    if (error = action.execute(action.state, action.delay)) {
        break;
    }
} while (action = actions.shift()); // exhaust the scheduler queue
this.active = false;
if (error) {
    while (action = actions.shift()) {
        action.unsubscribe();
    }
    throw error;
}
var _a;
