export { Subject, AnonymousSubject } from './Subject';
export { Observable } from './Observable';
export { config } from './config';
export { Operator } from './Operator';
export { Observer } from './types';
export { Subscription } from './Subscription';
export { Subscriber } from './Subscriber';
export { AsyncSubject } from './AsyncSubject';
export { ReplaySubject } from './ReplaySubject';
export { BehaviorSubject } from './BehaviorSubject';
export { ConnectableObservable } from './observable/ConnectableObservable';
export { Notification, NotificationKind } from './Notification';
export { EmptyError } from './util/EmptyError';
export { ArgumentOutOfRangeError } from './util/ArgumentOutOfRangeError';
export { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';
export { TimeoutError } from './util/TimeoutError';
export { UnsubscriptionError } from './util/UnsubscriptionError';
export { TimeInterval } from './operators/timeInterval';
export { Timestamp } from './operators/timestamp';
export { TestScheduler } from './testing/TestScheduler';
export { VirtualTimeScheduler } from './scheduler/VirtualTimeScheduler';
export { AjaxRequest, AjaxResponse, AjaxError, AjaxTimeoutError } from './observable/dom/AjaxObservable';
export { pipe } from './util/pipe';
import { AsapScheduler } from './scheduler/AsapScheduler';
import { AsyncScheduler } from './scheduler/AsyncScheduler';
import { QueueScheduler } from './scheduler/QueueScheduler';
import { AnimationFrameScheduler } from './scheduler/AnimationFrameScheduler';
import * as _operators from './operators/index';
export declare const operators: typeof _operators;
/**
 * @typedef {Object} Rx.Scheduler
 * @property {SchedulerLike} asap Schedules on the micro task queue, which is the same
 * queue used for promises. Basically after the current job, but before the next job.
 * Use this for asynchronous conversions.
 * @property {SchedulerLike} queue Schedules on a queue in the current event frame
 * (trampoline scheduler). Use this for iteration operations.
 * @property {SchedulerLike} animationFrame Schedules work with `requestAnimationFrame`.
 * Use this for synchronizing with the platform's painting.
 * @property {SchedulerLike} async Schedules work with `setInterval`. Use this for
 * time-based operations.
 */
declare let Scheduler: {
    asap: AsapScheduler;
    queue: QueueScheduler;
    animationFrame: AnimationFrameScheduler;
    async: AsyncScheduler;
};
/**
 * @typedef {Object} Rx.Symbol
 * @property {Symbol|string} rxSubscriber A symbol to use as a property name to
 * retrieve an "Rx safe" Observer from an object. "Rx safety" can be defined as
 * an object that has all of the traits of an Rx Subscriber, including the
 * ability to add and remove subscriptions to the subscription chain and
 * guarantees involving event triggering (can't "next" after unsubscription,
 * etc).
 * @property {Symbol|string} observable A symbol to use as a property name to
 * retrieve an Observable as defined by the [ECMAScript "Observable" spec](https://github.com/zenparsing/es-observable).
 * @property {Symbol|string} iterator The ES6 symbol to use as a property name
 * to retrieve an iterator from an object.
 */
declare let Symbol: {
    rxSubscriber: any;
    observable: any;
    iterator: symbol;
};
export { Scheduler, Symbol };
